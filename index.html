<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<title>MOBA Heist MVP — com Restart</title>
<style>
  body { margin:0; background:#111; font-family:Arial,Helvetica,sans-serif; overflow:hidden; }
  canvas { display:block; margin:auto; background:#5a9; box-shadow:0 8px 24px rgba(0,0,0,.5); }
  #overlay {
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    background:rgba(0,0,0,.75); color:white; z-index:40;
  }
  .card { background:#222; padding:15px; margin:10px; border-radius:8px; cursor:pointer; width:180px; text-align:center; }
  .card:hover { background:#333; }
  #topUI { position:absolute; top:8px; left:50%; transform:translateX(-50%); color:white; font-weight:bold; z-index:30; }
  #controls {
    position:absolute; top:10px; right:12px; z-index:30; display:flex; gap:8px;
  }
  .btn {
    background:#222; color:#fff; padding:8px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.08);
    cursor:pointer; font-weight:700;
  }
  .btn:hover { background:#2b2b2b; }
</style>
</head>
<body>
<canvas id="c" width="800" height="600"></canvas>
<div id="topUI"></div>

<div id="controls">
  <button id="restartBtn" class="btn">Restart</button>
  <button id="menuBtn" class="btn">Menu</button>
</div>

<div id="overlay">
  <div>
    <h2 style="margin:0 0 8px 0">Escolha sua classe</h2>
    <div style="display:flex; justify-content:center;">
      <div class="card" onclick="startGame('sniper')">Sniper<br><small>Long range • baixo HP</small></div>
      <div class="card" onclick="startGame('tank')">Tank<br><small>Alta vida • curto alcance</small></div>
      <div class="card" onclick="startGame('shotgun')">Shotgun<br><small>Ataque em cone • médio</small></div>
    </div>
    <div style="text-align:center; margin-top:8px; font-size:13px; opacity:0.9">
      Controles: W A S D para mover • Mouse para mirar • Clique esquerdo para atirar
    </div>
  </div>
</div>

<script>
/* ----- Config e utilitários ----- */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const topUI = document.getElementById('topUI');
const restartBtn = document.getElementById('restartBtn');
const menuBtn = document.getElementById('menuBtn');

const WORLD = { w:1600, h:900 };
const camera = { x:0, y:0 };
let loopStarted = false;

const CLASSES = {
  sniper: { hp:300, dmg:120, speed:3.5, range:550, spread:0, shots:1, ammoRecharge:1.8, attackCooldown:0.4 },
  tank: { hp:700, dmg:50, speed:2.2, range:80, spread:0, shots:1, ammoRecharge:2.2, attackCooldown:0.6 },
  shotgun:{ hp:450, dmg:60,  speed:3.0, range:160, spread:Math.PI/5, shots:5, ammoRecharge:2.0, attackCooldown:0.9 }
};

let entities = [], bullets = [], bushes = [], walls = [];
let player = null;
let running = false;
let currentClass = 'sniper'; // armazena classe escolhida para restart
let mouse = { x:0, y:0, down:false };
let keys = {};

/* Cofres (nomeado "cofre") */
const cofre = {
  blue: { x:60, y:405, w:90, h:90, hp:5000, maxHp:5000 },
  red:  { x:WORLD.w-150, y:405, w:90, h:90, hp:5000, maxHp:5000 },
};

/* ----- Input ----- */
window.addEventListener('mousemove', e=>{
  const r = canvas.getBoundingClientRect();
  mouse.x = e.clientX - r.left + camera.x;
  mouse.y = e.clientY - r.top + camera.y;
});
window.addEventListener('mousedown', e=>{ if(e.button===0) mouse.down=true; });
window.addEventListener('mouseup', e=>{ if(e.button===0) mouse.down=false; });
window.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

/* ----- Map inicial (12 bushes aproximadamente) ----- */
function createMap(){
  walls = [
    {x:780,y:200,w:40,h:200},
    {x:780,y:500,w:40,h:200},
    {x:300,y:400,w:40,h:200},
    {x:WORLD.w-340,y:400,w:40,h:200},
    {x:WORLD.w/2-260,y:120,w:120,h:40},
    {x:WORLD.w/2+140,y:740,w:120,h:40}
  ];
  bushes = [];
  const spots = [
    [400,200],[600,300],[500,500],[400,650],
    [800,150],[800,750],
    [1100,200],[1000,350],[1100,550],[1000,700],
    [600,450],[1200,450] // total 12
  ];
  spots.forEach(p => bushes.push({x:p[0], y:p[1], s:48}));
}

/* ----- Entidades (brawlers) ----- */
function spawn(team, x, y, cls, isPlayer=false){
  const def = CLASSES[cls];
  const e = {
    id: Math.random().toString(36).slice(2,9),
    x,y, vx:0, vy:0,
    team, classType:cls, isPlayer,
    hp:def.hp, maxHp:def.hp, radius:14, speed:def.speed,
    dmg:def.dmg, range:def.range, projSpeed: (def.range>300?12:10),
    shots:def.shots, spread:def.spread, attackCooldown:def.attackCooldown,
    ammoCapacity:3, ammo:3, ammoRecharge:def.ammoRecharge, lastAmmoTime: performance.now()/1000,
    lastShot:-999, lastDamagedAt:-999, alive:true, respawnAt:null,
    spawnX:x, spawnY:y, state:'idle', target:null
  };
  entities.push(e);
  if(isPlayer) player = e;
  return e;
}

/* ----- Colisões utilitárias ----- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1, y2-y1); }
function rectCircleCollide(rx,ry,rw,rh,cx,cy,r){ const closestX = clamp(cx, rx, rx+rw); const closestY = clamp(cy, ry, ry+rh); const dx = cx-closestX; const dy = cy-closestY; return dx*dx + dy*dy <= r*r; }
function circleCircleCollide(x1,y1,r1,x2,y2,r2){ return (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1) <= (r1+r2)*(r1+r2); }

/* ----- Movimento AI com melhor desvio de paredes ----- */
function moveAI(e, tx, ty){
  const angle = Math.atan2(ty - e.y, tx - e.x);
  const step = e.speed;
  let nx = e.x + Math.cos(angle) * step;
  let ny = e.y + Math.sin(angle) * step;
  // previsional: ver se ponto futuro colide
  if(!collidesWithWalls(nx, ny, e.radius)){
    e.x = nx; e.y = ny; return;
  }
  // tentar desviar: amostras angulares (pequeno leque)
  const tries = [Math.PI/4, -Math.PI/4, Math.PI/8, -Math.PI/8, Math.PI/2, -Math.PI/2];
  for(const t of tries){
    const a = angle + t;
    nx = e.x + Math.cos(a) * step;
    ny = e.y + Math.sin(a) * step;
    if(!collidesWithWalls(nx, ny, e.radius)){
      e.x = nx; e.y = ny; return;
    }
  }
  // se todas tentativas falharem, tenta mover pequeno passo inverso (destravar)
  e.x += Math.cos(angle + Math.PI) * 0.8;
  e.y += Math.sin(angle + Math.PI) * 0.8;
}

function collidesWithWalls(x, y, radius){
  // verifica se ponto futuro colide com qualquer wall
  for(const w of walls){
    if(rectCircleCollide(w.x, w.y, w.w, w.h, x, y, radius)) return true;
  }
  // bordas do mapa
  if(x - radius < 0 || y - radius < 0 || x + radius > WORLD.w || y + radius > WORLD.h) return true;
  return false;
}

/* ----- Tiro e projéteis ----- */
function fire(e, angle){
  if(!e.alive) return;
  const t = performance.now()/1000;
  if(t - e.lastShot < e.attackCooldown) return;
  if(e.ammo <= 0) return;
  e.lastShot = t;
  e.lastShotAt = t;
  e.ammo -= 1;
  e.lastAmmoTime = t;
  // multi-shot (shotgun)
  if(e.shots === 1){
    createBullet(e, angle);
  } else {
    const count = e.shots;
    for(let i=0;i<count;i++){
      const frac = (i - (count-1)/2) / ((count-1)/2 || 1);
      const a = angle + frac * (e.spread/2);
      createBullet(e, a);
    }
  }
}
function createBullet(e, angle){
  bullets.push({
    x: e.x + Math.cos(angle)*(e.radius+6),
    y: e.y + Math.sin(angle)*(e.radius+6),
    vx: Math.cos(angle)*(e.projSpeed || 10),
    vy: Math.sin(angle)*(e.projSpeed || 10),
    born: performance.now()/1000,
    life: 3.0,
    ownerId: e.id,
    team: e.team,
    dmg: e.dmg,
    r: 4
  });
}

/* ----- Dano, morte e respawn ----- */
function damageEntity(target, amount){
  if(!target.alive) return;
  target.hp -= amount;
  target.lastDamagedAt = performance.now()/1000;
  if(target.hp <= 0){
    target.alive = false;
    target.respawnAt = performance.now()/1000 + 5.0; // respawn exato 5s
  }
}
function handleRespawns(){
  const t = performance.now()/1000;
  for(const e of entities){
    if(!e.alive && e.respawnAt && t >= e.respawnAt){
      e.alive = true;
      e.hp = e.maxHp;
      e.x = e.spawnX; e.y = e.spawnY;
      e.respawnAt = null;
      e.lastDamagedAt = -999;
      e.lastShotAt = -999;
      e.ammo = e.ammoCapacity;
    }
  }
}

/* ----- Visibilidade em bush ----- */
function inBush(e){
  for(const b of bushes){
    if(e.x >= b.x && e.x <= b.x + b.s && e.y >= b.y && e.y <= b.y + b.s) return true;
  }
  return false;
}
function isVisibleTo(src, tgt){
  if(!tgt.alive) return false;
  // se alvo atirou recentemente ou foi danificado, fica visível (revelado) — aqui simplificado
  const revealUntil = (tgt.lastShotAt || -999) + 1.0;
  if(performance.now()/1000 <= revealUntil) return true;
  if(!inBush(tgt)) return true;
  // se adjacente (48px)
  if(dist(src.x, src.y, tgt.x, tgt.y) <= 48) return true;
  return false;
}

/* ----- AI simples com priorização ----- */
function aiUpdate(e){
  if(e.isPlayer || !e.alive) return;
  const enemies = entities.filter(x => x.team !== e.team && x.alive);
  // priorizar inimigo visível mais próximo
  let closest = null; let cd = Infinity;
  for(const en of enemies){
    if(!isVisibleTo(e, en)) continue;
    const d = dist(e.x,e.y,en.x,en.y);
    if(d < cd){ cd = d; closest = en; }
  }
  const myCofre = e.team === 'blue' ? cofre.blue : cofre.red;
  const enemyCofre = e.team === 'blue' ? cofre.red : cofre.blue;
  // se HP < 20% -> retirar (voltar spawn)
  if(e.hp / e.maxHp < 0.20){
    moveAI(e, e.spawnX, e.spawnY);
    return;
  }
  if(closest){
    // se em alcance, parar e atirar
    const d = dist(e.x,e.y,closest.x,closest.y);
    if(d <= e.range + 6){
      // mirar e atirar
      const ang = Math.atan2(closest.y - e.y, closest.x - e.x);
      fire(e, ang);
    } else {
      moveAI(e, closest.x, closest.y);
    }
    return;
  }
  // sem inimigos visíveis -> atacar cofre inimigo
  const dC = dist(e.x,e.y, enemyCofre.x + enemyCofre.w/2, enemyCofre.y + enemyCofre.h/2);
  if(dC <= e.range + 24){
    const ang = Math.atan2((enemyCofre.y+enemyCofre.h/2)-e.y, (enemyCofre.x+enemyCofre.w/2)-e.x);
    fire(e, ang);
  } else {
    moveAI(e, enemyCofre.x + enemyCofre.w/2, enemyCofre.y + enemyCofre.h/2);
  }
}

/* ----- Atualizações de munição e regen ----- */
function tickAmmo(e){
  const t = performance.now()/1000;
  if(e.ammo < e.ammoCapacity){
    if(t - (e.lastAmmoTime || 0) >= e.ammoRecharge){
      e.ammo = Math.min(e.ammoCapacity, e.ammo + 1);
      e.lastAmmoTime = t;
    }
  } else e.lastAmmoTime = t;
}
function regenTick(e, dt){
  const t = performance.now()/1000;
  const lastAction = Math.max(e.lastDamagedAt||-999, e.lastShotAt||-999);
  if(t - lastAction >= 2.0 && e.alive && e.hp < e.maxHp){
    const baseRate = 40;
    const rate = baseRate * (e.maxHp/400);
    e.hp = Math.min(e.maxHp, e.hp + rate * dt);
  }
}

/* ----- Atualizar projéteis ----- */
function updateBullets(dt){
  const t = performance.now()/1000;
  for(let i=bullets.length-1;i>=0;i--){
    const p = bullets[i];
    p.x += p.vx;
    p.y += p.vy;
    if(t - p.born >= p.life){ bullets.splice(i,1); continue; }
    // parede
    let hitWall = false;
    for(const w of walls) if(rectCircleCollide(w.x,w.y,w.w,w.h, p.x,p.y,p.r)) { hitWall = true; break; }
    if(hitWall){ bullets.splice(i,1); continue; }
    // cofre
    if(p.team === 'blue'){
      if(rectCircleCollide(cofre.red.x, cofre.red.y, cofre.red.w, cofre.red.h, p.x,p.y,p.r)){
        cofre.red.hp = Math.max(0, cofre.red.hp - p.dmg);
        bullets.splice(i,1); continue;
      }
    } else {
      if(rectCircleCollide(cofre.blue.x, cofre.blue.y, cofre.blue.w, cofre.blue.h, p.x,p.y,p.r)){
        cofre.blue.hp = Math.max(0, cofre.blue.hp - p.dmg);
        bullets.splice(i,1); continue;
      }
    }
    // brawlers (inimigos)
    for(const e of entities){
      if(!e.alive) continue;
      if(e.team === p.team) continue;
      if(circleCircleCollide(p.x,p.y,p.r, e.x,e.y, e.radius)){
        damageEntity(e, p.dmg);
        bullets.splice(i,1);
        break;
      }
    }
  }
}

/* ----- Resolução colisões de entidade com paredes ----- */
function resolveWallCollision(e){
  for(const w of walls){
    if(rectCircleCollide(w.x,w.y,w.w,w.h, e.x,e.y,e.radius)){
      // empurra para fora
      const closestX = clamp(e.x, w.x, w.x + w.w);
      const closestY = clamp(e.y, w.y, w.y + w.h);
      let dx = e.x - closestX, dy = e.y - closestY;
      let d2 = dx*dx + dy*dy;
      if(d2 === 0){
        dx = 1; dy = 0; d2 = 1;
      }
      const d = Math.sqrt(d2);
      const overlap = e.radius - d + 0.5;
      if(overlap > 0){
        e.x += (dx/d) * overlap;
        e.y += (dy/d) * overlap;
      }
    }
  }
  e.x = clamp(e.x, e.radius, WORLD.w - e.radius);
  e.y = clamp(e.y, e.radius, WORLD.h - e.radius);
}

/* ----- Atualização principal ----- */
let lastTime = performance.now();
function update(){
  if(!running) return;
  const now = performance.now();
  const dt = (now - lastTime) / 1000;
  lastTime = now;

  // respawns
  handleRespawns();

  // player control
  if(player && player.alive){
    let mx = 0, my = 0;
    if(keys['w']) my -= 1;
    if(keys['s']) my += 1;
    if(keys['a']) mx -= 1;
    if(keys['d']) mx += 1;
    if(mx !== 0 || my !== 0){
      const len = Math.hypot(mx,my) || 1;
      player.x += (mx/len) * player.speed;
      player.y += (my/len) * player.speed;
      resolveWallCollision(player);
    }
    // atirar com mouse
    if(mouse.down){
      const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
      if(performance.now()/1000 - (player.lastShot || -999) >= player.attackCooldown && player.ammo > 0){
        player.lastShot = performance.now()/1000;
        player.lastShotAt = performance.now()/1000;
        player.ammo -= 1;
        player.lastAmmoTime = performance.now()/1000;
        // disparo multi
        if(player.shots === 1) createBullet(player, ang);
        else {
          for(let i=0;i<player.shots;i++){
            const frac = (i - (player.shots-1)/2) / ((player.shots-1)/2 || 1);
            createBullet(player, ang + frac * (player.spread/2));
          }
        }
      }
    }
  }

  // AI
  for(const e of entities){
    tickAmmo(e);
    regenTick(e, dt);
    if(!e.isPlayer) aiUpdate(e);
  }

  updateBullets(dt);

  // keep camera following player
  if(player){
    camera.x = clamp(player.x - canvas.width/2, 0, WORLD.w - canvas.width);
    camera.y = clamp(player.y - canvas.height/2, 0, WORLD.h - canvas.height);
  }

  // check win
  if(cofre.blue.hp <= 0 || cofre.red.hp <= 0){
    running = false;
    overlay.style.display = 'flex';
    overlay.querySelector('h2').innerText = cofre.blue.hp <= 0 ? 'Time Vermelho Venceu!' : 'Time Azul Venceu!';
  }
}

/* ----- Desenho ----- */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(-camera.x, -camera.y);

  // fundo
  ctx.fillStyle = '#5a9';
  ctx.fillRect(0,0,WORLD.w,WORLD.h);

  // bushes
  for(const b of bushes){
    ctx.fillStyle = 'rgba(0,100,0,0.7)';
    ctx.fillRect(b.x, b.y, b.s, b.s);
    ctx.strokeStyle = 'rgba(0,40,0,0.4)';
    ctx.strokeRect(b.x,b.y,b.s,b.s);
  }

  // walls
  for(const w of walls){
    ctx.fillStyle = '#665';
    ctx.fillRect(w.x,w.y,w.w,w.h);
    ctx.strokeStyle = '#332';
    ctx.strokeRect(w.x,w.y,w.w,w.h);
  }

  // cofres (squares grandes)
  function drawCofre(c, color){
    ctx.fillStyle = color;
    ctx.fillRect(c.x, c.y, c.w, c.h);
    ctx.fillStyle = 'rgba(0,0,0,0.22)';
    ctx.fillRect(c.x + c.w*0.12, c.y + c.h*0.12, c.w*0.76, c.h*0.76);
    // HP bar
    const barW = 180;
    const bx = c.x + c.w/2 - barW/2;
    const by = c.y - 18;
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(bx,by,barW,10);
    const ratio = c.hp / c.maxHp;
    ctx.fillStyle = ratio>0.5 ? '#2b8' : (ratio>0.2 ? '#fa0' : '#f33');
    ctx.fillRect(bx+2, by+2, (barW-4) * clamp(ratio,0,1), 6);
    ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.strokeRect(bx,by,barW,10);
    // label "Cofre"
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Cofre', c.x + c.w/2, c.y + c.h + 14);
  }
  drawCofre(cofre.blue, '#2f9cff');
  drawCofre(cofre.red, '#ff5555');

  // bullets
  for(const p of bullets){
    ctx.beginPath();
    ctx.fillStyle = '#ffeb3b';
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();
  }

  // brawlers
  for(const e of entities){
    if(!e.alive) continue;
    // se em bush, semitransparente
    const inB = inBush(e);
    ctx.globalAlpha = inB ? 0.55 : 1.0;
    ctx.beginPath();
    ctx.fillStyle = e.team === 'blue' ? '#2f9cff' : '#ff5555';
    ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 2; ctx.stroke();
    ctx.globalAlpha = 1.0;
    // barra de hp
    const hpRatio = e.hp / e.maxHp;
    const bw = e.radius * 2.8;
    const bx = e.x - bw/2, by = e.y - e.radius - 12;
    ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(bx,by,bw,8);
    ctx.fillStyle = hpRatio>0.5 ? '#2b8' : (hpRatio>0.2 ? '#fa0' : '#f33');
    ctx.fillRect(bx+1, by+1, (bw-2) * clamp(hpRatio,0,1), 6);
    ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.strokeRect(bx,by,bw,8);
    // ammo dots
    const ammoX = e.x - 12, ammoY = e.y + e.radius + 8;
    for(let a=0;a<e.ammoCapacity;a++){
      ctx.beginPath();
      ctx.fillStyle = a < e.ammo ? '#ffeb3b' : 'rgba(255,255,255,0.15)';
      ctx.arc(ammoX + a*9, ammoY, 3, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // dead: respawn timer visuals
  for(const e of entities){
    if(e.alive) continue;
    if(e.respawnAt){
      const left = Math.max(0, Math.ceil(e.respawnAt - performance.now()/1000));
      ctx.beginPath();
      ctx.fillStyle = e.team === 'blue' ? '#2f9cff' : '#ff5555';
      ctx.arc(e.spawnX, e.spawnY, 10, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#fff'; ctx.font = '10px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(left, e.spawnX, e.spawnY);
    }
  }

  ctx.restore();

  // top UI
  topUI.innerText = `Cofre Azul: ${Math.max(0, Math.round(cofre.blue.hp))}   —   Cofre Vermelho: ${Math.max(0, Math.round(cofre.red.hp))}`;
}

/* ----- Loop principal ----- */
function gameLoop(){
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

/* ----- Iniciar/Resetar jogo ----- */
function clearState(){
  entities = []; bullets = []; bushes = []; walls = [];
  player = null;
  // reset cofres
  cofre.blue.hp = cofre.blue.maxHp;
  cofre.red.hp = cofre.red.maxHp;
}

function spawnTeams(chosenClass){
  const blueSpawnX = cofre.blue.x + cofre.blue.w + 40, blueSpawnY = cofre.blue.y + cofre.blue.h/2;
  const redSpawnX = cofre.red.x - 40, redSpawnY = cofre.red.y + cofre.red.h/2;
  spawn('blue', blueSpawnX, blueSpawnY-60, chosenClass, true); // player
  spawn('blue', blueSpawnX, blueSpawnY + 20, 'shotgun');
  spawn('blue', blueSpawnX, blueSpawnY + 100, 'tank');
  spawn('red', redSpawnX, redSpawnY-100, 'sniper');
  spawn('red', redSpawnX, redSpawnY + 20, 'shotgun');
  spawn('red', redSpawnX, redSpawnY + 100, 'tank');
}

function startGame(chosenClass){
  currentClass = chosenClass || currentClass;
  overlay.style.display = 'none';
  clearState();
  createMap();
  spawnTeams(currentClass);
  // ensure coffres hp reset to 5000
  cofre.blue.hp = cofre.blue.maxHp = 5000;
  cofre.red.hp = cofre.red.maxHp = 5000;
  running = true;
  lastTime = performance.now();
  // start loop only once
  if(!loopStarted){ loopStarted = true; gameLoop(); }
}

/* ----- Restart usando mesma classe (botão) ----- */
function restartGame(){
  // reinicia o jogo com a mesma classe selecionada anteriormente
  running = false;
  // pequena pausa para garantir limpeza (não necessário mas seguro)
  setTimeout(()=>{
    startGame(currentClass);
  }, 60);
}
restartBtn.addEventListener('click', restartGame);

/* ----- Menu: voltar para seleção de classe ----- */
menuBtn.addEventListener('click', ()=>{
  running = false;
  overlay.style.display = 'flex';
  overlay.querySelector('h2').innerText = 'Escolha sua classe';
});

/* ----- Inicial (exibe menu) ----- */
createMap();
overlay.style.display = 'flex';

/* ----- Iniciar loop (será ativado quando startGame for chamado) ----- */
gameLoop();

</script>
</body>
</html>
